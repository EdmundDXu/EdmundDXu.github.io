---
author: edmund
comments: true
date: 2018-05-02 13:41:50+00:00
layout: post
link: http://118.25.17.78/blog/2018/05/02/linux%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%ef%bc%88ext%e7%b3%bb%e5%88%97%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%ef%bc%89%e4%b8%8e%e7%a1%ac%e9%93%be%e6%8e%a5%e3%80%81/
slug: linux%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%bb%84%e7%bb%87%e7%bb%93%e6%9e%84%ef%bc%88ext%e7%b3%bb%e5%88%97%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%ef%bc%89%e4%b8%8e%e7%a1%ac%e9%93%be%e6%8e%a5%e3%80%81
title: Linux文件系统组织结构（ext系列文件系统）与硬链接、软连接
wordpress_id: 215
categories:
- Linux技术
- Linux随笔
post_format:
- 日志
tags:
- linux
- 文件系统管理
---

# 文件系统




计算机的[文件系统](https://en.wikipedia.org/wiki/File_system)是一种存储和组织计算机中的数据的方法，它使得数据的访问和查找变得容易。文件系统使用文件和树形目录代替了硬盘和光盘中类似扇区的概念，使用文件系统读取文件时，就不需要知道文件占用了哪几个扇区，地址是多少，只需要记住文件所在的目录和文件名，就可以访问到这个文件中的数据。使用文件系统存储文件时，用户也不需要知道哪些扇区已经被使用，还有哪些扇区空闲，或者有哪些连续的扇区，只需要在文件系统中直接创建文件或目录，管理磁盘块的工作会由该文件系统来完成，用户只需要记住文件所在路径和文件名即可。




而ext系列的文件系统是Linux上直至早些年都一直备受推崇的文件系统，所以在这里只讲ext系列的文件系统。以后提到Linux文件系统均指代ext系列文件系统。





# Linux文件系统组织结构




## 数据块（block）和块位图（block bitmap）




在Linux文件系统中，可用空间被划分成数据块（block），数据块的大小一般是扇区大小的倍数，比如1K、2K、4K、8K块，数据块是存储数据的最小单位。




此时，我们在创建文件时，就可以为每个文件分配合适数量的数据块，然后记录下这些数据块的地址，在读取时根据这些地址就可以知道文件的内容。上面这句话看起来好像很简单，但是我们再仔细看一下，文件系统要如何分配数据块呢？首先，文件系统需要知道哪些数据块被占用了，哪些数据块没有被占用。然后，根据需求决定是不是要查找地址连续的数据块，最后找到这些数据块并且告知数据块的地址。那么文件系统要怎么知道数据块是不是空闲的呢？我们可以在每个数据块首部加一个标志位，0表示这个数据块没有被占用，1表示这个数据块被占用了，每次这个数据块分配就把它置为1，被释放就把它置为0，这样子好像就解决问题了，我们已经能找到空闲的数据块了。




但是冷静思考一下，我们会发现我们虽然知道了某一个数据块是不是空闲的，但是为了找到某一个空闲的数据块，我们必须遍历数据块区，以找到第一个空闲的数据块，然后根据需求决定是不是要继续找下一个空闲的数据块分配给文件使用，这样一旦文件系统的空间变得非常大，查找的速度会非常慢，对于用户来说肯定是无法忍受的，所以，我们就可以对数据块建立一个索引，每个数据块对应索引中的一位，该位置为0表示对应数据块为空闲，1表示被占用。这样每次需要分配数据块时，只需要遍历这个索引就能够很快找到空闲的数据块。而在Linux文件系统中这个索引称为块位图（block bitmap）。




![](http://118.25.17.78/wp-content/uploads/2018/05/bitmap1.jpg)




此时文件系统空间被分为两块，一块是数据区（data），一块是元数据区（meta data），数据区存储文件的内容，元数据区存储块位图。





## inode和inode位图（inode bitmap）




但是光有数据块还不行，因为如果只有数据块的话，在文件存取时，用户就需要知道这个文件对应的是哪些数据块，然后记录下这些数据块的地址，在需要的时候一个一个读出来。所以我们需要有一个代理人帮我们存储这些信息，这个代理人就是inode（index node 索引节点）。




在Linux文件系统中，每个文件或目录都对应一个inode，每个inode有一个inode号，因为inode也需要存储数据，所以很明显，inode也需要占用数据块。在inode中保存有inode号、文件的大小、文件的权限、文件的属主属组、文件所对应的数据块地址等信息，**需要注意的是，文件名并不包含在inode中**。换句话说，inode中保存了一个文件的元数据（meta data），通过inode，我们就可以找到这个文件中存储的数据（data）。这个时候，元数据区又划分出了一块inode区，用于存储每一个inode。




**注：这里补充说一点，由于分配给一个inode的空间是有限的，所以inode中保存的地址不可能过长，这时候就会出现无法保存尽可能多的数据块地址的情况，假设一个块大小为4K，一个inode最多只能够存储100个数据块地址，那么单个文件最大就只有400K，这个大小对于现代操作系统来说远远不够，所以，我们需要拓展inode所能够保存的地址空间，这就引出了多级指针的概念，inode中的某些存储区域并不直接存储数据所在数据块的地址（直接指向存储数据所在数据块的地址的指针称为直接指针），而是存储另一个数据块的地址，这个数据块中存储数据所在数据块的地址，此时，能够存储的空间就已经几何倍数增长了，这个指向另一个数据块地址的指针称为间接指针，而在二级指针中不存储数据所在数据块的地址，而是存储另外的数据块的地址，这个指针就称为双重间接指针指针，此时，已经能够存储足够大的数据了。在ext2文件系统中有一个有15个指针的结构。指针1至12指向直接块，指针13指向间接块，指针14指向双重间接块，并且指针15指向三重间接块。**




是不是感觉轻松多了呢，我们只需要知道一个文件的inode，就可以找到这个文件。但是这个时候问题又来了，如果我们需要存储一个文件，那么有了inode以后，我们应该先为这个文件分配一个inode，所以，需要找一个空闲的inode分配给这个文件使用。如何找一个空闲的inode出来，和数据块一样，我们也可以通过在inode首部添加一个标志位，然后对inode区进行遍历以获取空闲的inode，但是我们又说过这种方式在空间庞大的时候会显得特别低效，所以我们也给inode画一张位图，用于显示inode的空闲与否，这个位图就叫做inode位图（inode bitmap）。




![](http://118.25.17.78/wp-content/uploads/2018/05/inode-bitmap.jpg)





## 块组（block group）




虽然我们可以通过bitmap的方式建立索引，来避免对大量数据的遍历，但是当数据量继续增大时，即便是bitmap也会变得很大，这个时候遍历的速度又会变得缓慢起来，此时，我们就不能对数据进行平面化管理。思考一下国家的管理方式，领导并不是对整个国家进行管理，而是分而治之，将国家划分为多个地区进行分别管理。同样，文件系统也可以将存储区划分为多个，每个存储区称为块组（block group），每个块组中都包含有一个数据区（data），一个元数据区（meta data），元数据区中包含有一个块位图（block bitmap），一个inode位图（inode bitmap），一个inode区。有了块组后，为文件分配数据块时，会尽量将同一个文件的数据块分配到同一个块组中，这样做是为了尽量减少读取大量连续数据时的磁盘搜索次数。




![](http://118.25.17.78/wp-content/uploads/2018/05/block-group1.jpg)





## 超级块（Superblock）和块组描述符表（block Group Descriptor Table, GDT）




超级块是描述整个分区的文件系统信息的特殊数据块，比如块大小、文件系统版本号、文件系统类型，空闲块数、占用块数、上次 mount的时间、GDT的大小以及备份数量等等文件系统信息，以及对于启动操作系统至关重要的重要信息，因此超级块一旦损坏，这个文件系统将成为板砖，毫无用处。所以超级块会有多个备份存在，每个块组的开头都会保存一个超级块的副本。




如果说超级块保存的是整个文件系统的全局信息，那么块组描述符（Group Descriptor）中保存的就是每个块组的信息，而块组描述符表（GDT）则包含有多个块组描述符。每个块组描述符中都保存了一个块组的描述信息，如在这个块组中从哪里开始是 inode表，超级块备份的位置、块位图的位置、inode位图的位置、从哪里开始是数据块，空闲的 inode和数据块还有多少个等等。一旦块组描述符损坏，那么整个块组的信息就会丢失，所以和超级块一样，块组描述符表（GDT）在每个块组的开头也留有备份，一旦某个GDT出现损坏，只需要将备份的GDT拷贝过来即可。




![](http://118.25.17.78/wp-content/uploads/2018/05/superblock.jpg)





## 目录（directory）




上面我们一直在说inode和文件的对应关系，只要知道了inode号，就可以找到文件对应的数据块地址，进而能够读取出文件中保存的数据，但是，这个inode号保存在哪里？总不能用一个小本本记录吧，这样不就又回到之前的窘境了。还有，前面说的文件名到底保存在哪里？这里就需要提出目录的概念了。




其实在Linux中，目录也是一个文件，只不过普通文件存储的是数据，而目录中存储的是一张表，这个表中有多个条目，每个条目表示一个文件，每个条目中包含一个文件的文件名，文件对应的inode号，文件名的长度等信息。这样在读取一个文件的内容时，就可以通过文件名查找目录中的条目，通过条目取出文件的inode号，然后根据inode号查找inode表，找到inode后取出数据块的地址，根据地址就能够取出文件的内容了。




我们知道，只要我们登录进了Linux操作系统，我们就一定会在某个目录中，这个目录称作工作目录（working directory），因此，我们在创建文件时，一定会是在某个目录下创建文件，如此，创建文件的动作就如下所述：




（1）首先通过inode bitmap查找到一个空闲的inode。




（2）然后通过block bitmap找到足够数量的空闲的block。




（3）接着将block的地址写入inode中。




（4）最后将文件名和inode号写入当前目录的列表中




![](http://118.25.17.78/wp-content/uploads/2018/05/directory.jpg)





## 硬链接




有了上面的知识背景，就容易理解硬链接了。硬链接其实是一条指向一个inode的路径。比如，/etc/passwd是一个文件路径，这个文件路径指向的inode号为68686，那么这个文件路径就是68686这个inode的一个硬链接。如果此时还有一个文件路径是/tmp/passwd，这个文件路径指向的inode号也是68686,那么这个文件路径就是68686这个inode的又一个硬链接。




每次对一个文件创建一个硬链接，这个文件的被链接数就会加1。而当一个文件被删除时，被链接数会减1，当被链接数减到0的时候，这个文件才会被真正删除，这个文件占用的inode和block才会被释放。





### 硬链接的创建方法: 




**ln [OPTION]... SRC... DEST** 为SRC创建一个硬链接DEST





下面我们来创建一个文件hard，同时为它创建一个硬链接hard.hl。





<blockquote>

> 
> [root@edu test]# touch hard
[root@edu test]# echo hard > hard
[root@edu test]# ls -l
total 4
-rw-r--r--. 1 root root 5 May 2 20:18 hard
[root@edu test]# ln -v hard hard.hl
‘hard.hl’ => ‘hard’
[root@edu test]# ls -l
total 8
-rw-r--r--. 2 root root 5 May 2 20:18 hard
-rw-r--r--. 2 root root 5 May 2 20:18 hard.hl
> 
> 
</blockquote>




我们可以观察到，这两个文件完全相同，为了确定它们就是同一个文件，我们使用ls 的-i选项查看文件的inode号。





<blockquote>

> 
> [root@edu test]# ls -li
total 8
68688 -rw-r--r--. 2 root root 5 May 2 20:18 hard
68688 -rw-r--r--. 2 root root 5 May 2 20:18 hard.hl
> 
> 
</blockquote>




果然，这两个文件路径指向了同一个inode，所以这两个文件路径访问的其实就是同一个文件。我们修改hard.hl的内容，观察结果。





<blockquote>

> 
> [root@edu test]# echo hard.hl > hard.hl 
[root@edu test]# ls -li
total 8
68688 -rw-r--r--. 2 root root 8 May 2 20:21 hard
68688 -rw-r--r--. 2 root root 8 May 2 20:21 hard.hl
> 
> 
</blockquote>




这两个路径指向的文件的大小同时发生的更改，果然，它们修改的是同一个文件。此时，我为hard创建一个副本hard.cp，观察结果。





<blockquote>

> 
> [root@edu test]# cp hard hard.cp
[root@edu test]# ls -li
total 12
68688 -rw-r--r--. 2 root root 8 May 2 20:21 hard
68689 -rw-r--r--. 1 root root 8 May 2 20:22 hard.cp
68688 -rw-r--r--. 2 root root 8 May 2 20:21 hard.hl
> 
> 
</blockquote>




hard.cp的inode号和hard不同，可以断定它们是两个文件。




说到这里，不知道大家有没有注意到ls -l列出的信息的第三个字段，这个字段表示的是这个文件被硬链接的次数。我们可以很清楚的从上面的输出观察到，一个新创建的inode一开始只有一个文件路径（/tmp/test/hard.cp）指向它，所以硬链接次数为1，而68688这个inode，由于为它又创建了一个新的硬链接（/tmp/test/hard.hl），硬链接次数加1，所以被硬链接的次数为2。此时我如果删除hard.hl,68688这个inode代表的文件不会被删除，只是硬链接次数会减1.





<blockquote>

> 
> [root@edu test]# rm hard.hl 
rm: remove regular file ‘hard.hl’? y
[root@edu test]# ls -li
total 8
68688 -rw-r--r--. 1 root root 8 May 2 20:21 hard
68689 -rw-r--r--. 1 root root 8 May 2 20:22 hard.cp
> 
> 
</blockquote>




一旦我删除了硬链接次数为1的文件，使其的硬链接次数变为0，那么这个文件就会真正的被删除。





硬链接在使用上有两点需要注意：




**（1）不能够对目录创建硬链接**




**（2）不能够跨分区（文件系统）创建硬链接**




想必第二点不能够跨文件系统创建硬链接是很好理解的，因为硬链接直接对应inode号，而inode号只针对于某个文件系统，如果跨文件系统，那么在另一个文件系统中这个inode号对应的文件就会发生变化，所以不能够跨越文件系统创建硬链接。




对于第一点，网上有一个朋友的解释很清晰。




linux系统中的硬连接有两个限制：不能跨越文件系统和不允许普通用户对目录作硬连接。至于第一个限制，很好理解，而第二个就不那么好理解了。 我们对任何一个目录用ls -l 命令都可以看到其连接数至少是2，这也说明了系统中是存在硬连接的，而且命令ln -d 也可以让超级用户对目录作硬连接，这些都说明了系统限制对目录进行硬连接只是一个硬性规定，并不是逻辑上不允许或技术上的不可行。那么操作系统为什么要进行限制呢？




如果引入了对目录的硬连接就有可能在目录中引入循环，那么在目录遍历的时候系统就会陷入无限循环当中。也许您会说，符号连接不也可以引入循环吗，那么为什么不限制目录的符号连接呢？原因就在于在linux系统中，每个文件(目录也是文件)都对应着一个inode结构，其中inode数据结构中包含了文件类型(目录，普通文件，符号连接文件等等)的信息，也就是说操作系统在遍历目录时可以判断出符号连接，既然可以判断出符号连接当然就可以采取一些措施来防范进入过大的循环了，系统在连续遇到8个符号连接后就停止遍历，这就是为什么对目录符号连接不会进入死循环的原因了。但是对于硬连接，由于操作系统中采用的数据结构和算法限制，目前是不能防范这种死循环的。





<blockquote>

> 
> 
</blockquote>




## 软链接（符号链接，symbolic link）




软链接比起硬链接就要好理解一些，因为软链接就类似于windows操作系统中的快捷方式，本身并不存储数据，而是存储一个文件路径。




我们知道，一个文件如果要存储数据，那么就要为其分配一个inode和数个block，然后在inode中保存block的地址。但是软链接不同，软链接在被创建出来后也会被分配一个inode，但是这个inode并不会保存block的地址，而是保存一个字符串，所以软链接基本上不会占用磁盘空间。这个字符串就是一个文件路径，文件系统能够根据这个文件路径去寻找这个软链接指向的文件。




所以通过软链接访问文件的步骤就如下所述：




**（1）文件系统通过查询目录列表找到软链接对应的inode号**




**（2）文件系统通过inode号查询inode表，找到对应的inode**




**（3）文件系统通过inode上面保存的文件信息的得知这个文件是软链接文件，所以会将inode中保存数据块地址的地方解释为文件路径。**




**（4）文件系统通过这个文件路径逐级开始访问真正指向的文件。**





### 软链接的创建方法:




**ln [OPTIONS...] -s SRC TARGET**    为SRC创建软链接TARGET。




下面我们来创建一个文件soft，同时为它创建一个软链接soft.sl。





<blockquote>

> 
> [root@edu test]# touch soft
[root@edu test]# ln -sv soft soft.sl
‘soft.sl’ -> ‘soft’
[root@edu test]# ls -li
total 4
68690 -rw-r--r--. 1 root root 0 May 2 20:42 soft
68691 lrwxrwxrwx. 1 root root 4 May 2 20:42 soft.sl -> soft
> 
> 
</blockquote>




我们可以看出，soft和soft.sl的inode号不同，为两个文件，这里值得注意的是soft.sl这个软链接的大小，是4个字节，这是为什么呢？因为软链接中保存的是文件路径，而这里文件路径是soft，刚好是4个字节，所以就显示为4。




如果我对/etc/passwd创建软链接passwd.sl，那么这个软链接的占据的大小应该是11个字节，因为这个路径有11个字符嘛。





<blockquote>

> 
> [root@edu test]# ln -sv /etc/passwd passwd.sl
‘passwd.sl’ -> ‘/etc/passwd’
[root@edu test]# ls -li
total 8
68692 lrwxrwxrwx. 1 root root 11 May 2 20:44 passwd.sl -> /etc/passwd
68690 -rw-r--r--. 1 root root 0 May 2 20:42 soft
68691 lrwxrwxrwx. 1 root root 4 May 2 20:42 soft.sl -> soft
> 
> 
</blockquote>




没错吧。



