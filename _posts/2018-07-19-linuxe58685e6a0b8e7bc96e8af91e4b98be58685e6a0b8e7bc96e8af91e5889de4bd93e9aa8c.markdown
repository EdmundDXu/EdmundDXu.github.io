---
author: edmund
comments: true
date: 2018-07-19 09:48:19+00:00
layout: post
link: http://118.25.17.78/blog/2018/07/19/linux%e5%86%85%e6%a0%b8%e7%bc%96%e8%af%91%e4%b9%8b%e5%86%85%e6%a0%b8%e7%bc%96%e8%af%91%e5%88%9d%e4%bd%93%e9%aa%8c/
slug: linux%e5%86%85%e6%a0%b8%e7%bc%96%e8%af%91%e4%b9%8b%e5%86%85%e6%a0%b8%e7%bc%96%e8%af%91%e5%88%9d%e4%bd%93%e9%aa%8c
title: Linux内核编译之内核编译初体验
wordpress_id: 577
categories:
- Linux技术
post_format:
- 日志
tags:
- CentOS 6
- kernel
- 源码编译
- 硬件
---

# 前言




在前面讲到[Linux系统启动流程中的ramdisk](http://118.25.17.78/blog/2018/07/02/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8Bcentos%E7%AF%87/#ramdisk)时，我曾提到Linux是一个模块化的单内核设计架构，这使得Linux内核可以只将一些启动系统所必要的功能编译进内核，而其他的功能可以编译成模块放在文件系统中，需要用到某个功能时只需要加载对应的模块就好了。Linux内核也因此变得非常小，而又不失灵活性。在我们日常使用中一般不需要自行编译内核，直接使用发行版提供的已经编译好的内核即可。但是当企业中有一些特殊需要时，我们就必须自行编译内核，根据业务判断哪些功能需要开启或关闭，哪些功能需要编译进内核而哪些功能需要编译成模块。




想要熟练地编译内核是非常困难的，这意味着你需要弄清楚几乎每一个内核版本的每一个选项的意义，还有各个内核功能之间的依赖关系，一个不对，就会导致编译好的内核无法使用或者是崩溃，甚至无法完成编译。在这里我们将省去这个步骤，直接使用CentOS官方为我们提供的选项配置，而不是我们自行配置内核选项，这将为我们省去大量的查阅资料的时间，而且又能够轻松地了解编译内核的流程是怎么样的。







# 内核编译大致流程




## 准备好开发环境




和编译任何一个软件项目一样，我们在编译之前必须准备好编译环境，否则编译将无法完成。




在这里我使用的是CentOS 6，开发需要CentOS 6源中的两个包组 ：Server Platform Development和Development Tools。




就算你使用的发行版和我的不同也没关系，你可以去查阅一下文档了解一下开发环境，或者根据在编译过程中的报错信息依次安装开发环境。




不要担心编译出错后需要重新编译，当你解决了开发环境的问题后，编译过程会从上次出错的地方继续。







## 获取目标主机上硬件设备相关信息




### CPU信息




#### /proc/cpuinfo




还记得procfs中的cpuinfo文件吗，这个文件中存储的就是CPU的信息。




![](http://118.25.17.78/wp-content/uploads/2018/07/cpuinfo.png)




 




#### x86info




如果你确定你的CPU是x86的架构，那么你可以使用x86info查看CPU的详细信息。




![](http://118.25.17.78/wp-content/uploads/2018/07/x86info.jpg)




 




#### lscpu




lscpu命令会从sysfs和/proc/cpuinfo中获取CPU信息，然后以易读的方式打印出来。




![](http://118.25.17.78/wp-content/uploads/2018/07/lscpu.jpg)




 




### PCI设备信息




#### lspci




lspci命令显示系统上的PCI总线和连接在PCI总线上的设备信息。可以使用-v、-vv、-vvx、-vvxx、-vvxxx等选项显示更加详细的内容。




![](http://118.25.17.78/wp-content/uploads/2018/07/lspci.jpg)







#### lsusb




lsusb命令显示系统上的所有USB总线和连接在总线上的设备信息。同样的也可以使用-v、-vv显示更加详细的信息。




![](http://118.25.17.78/wp-content/uploads/2018/07/lsusb.jpg)




 




### 查看所有设备信息




#### hal-device




硬件抽象层 (HAL，Hardware Abstraction Layer) 为用户提供了一个标准的视图，用户可以在视图上看到连接到系统上的所有的硬件设备。hal-device命令允许你能够以遵循HAL标准的方式管理这些设备，包括添加、删除和查看设备信息。




由于hal-device命令会打印出所有的设备信息，所以为了方便快速地定位某个设备，我们一般会结合less和grep命令。




比如查看本机网卡驱动，我们先根据网卡名eth0来找到和eth0相关的信息。在hal-device输出的索引为25的设备中，我们发现他还有一个physical_device字段，指明了这个网络设备的真实物理设备，然后我们根据这个物理设备的udi来查找网卡设备。




![](http://118.25.17.78/wp-content/uploads/2018/07/hal-device1-1.jpg)




果然我们在索引为100的位置找到了这个网卡设备，并且发现它有个driver字段，这就表示这个网卡设备所使用的驱动为e1000。




![](http://118.25.17.78/wp-content/uploads/2018/07/hal-device2-3.jpg)




 




#### dmesg




dmesg命令用于查看内核引导阶段打印的缓冲区信息，其中就包含了探测硬件时打印的信息。所以我们可以通过查看内核打印的信息来获取硬件信息。




同样的也是查看网卡驱动，我们发现很快的就能够找到网卡设备和网卡驱动。




![](http://118.25.17.78/wp-content/uploads/2018/07/dmesg.jpg)




然后我们再查看硬盘信息，通过sd为关键字查找。在输出的第11行我们发现我们的硬盘为SCSI设备。




![](http://118.25.17.78/wp-content/uploads/2018/07/dmesg-2.jpg)




 




注意：这里就只做一些常用设备信息的介绍，需要获取更多的设备信息可以通过procfs和sysfs，这里面保存了大部分内核探测到的硬件信息。或者你可以参考别人整理好的方法 : [Linux 查看系统硬件信息(实例详解)](https://www.cnblogs.com/ggjucheng/archive/2013/01/14/2859613.html)，[linux查看硬件设备信息](https://www.cnblogs.com/batcom/archive/2012/06/20/2556099.html) 等等。




 




## 获取目标主机系统相关信息，比如需要启用的文件系统模块。




### 文件系统




#### blkid




blkid用于打印指定块设备的属性，比如UUID、文件系统类型等。在使用blkid时，可以结合df -lh或者是fdisk -l命令查看系统上的块设备。




![](http://118.25.17.78/wp-content/uploads/2018/07/blkid.jpg)







#### lsblk




lsblk从sysfs中读取数据，用于查看所有的块设备信息。其中--fs选项可以查看块设备上的文件系统信息。




![](http://118.25.17.78/wp-content/uploads/2018/07/lsblk.jpg)




 




## 获取一个指定版本的内核源代码包




源码包的获取方式有很多种，比如你可以从本地仓库获取，从远程仓库获取，从搜索引擎中获取，从www.kernel.org中获取。




这里我们从www.kernel.org中取得一个2.6.32版本的内核，因为CentOS 6使用的内核版本为2.6.32，你也可以使用更新的版本，但是如果使用更新的版本，那么CentOS 6提供的内核配置文件中的选项和新版本的内核中的选项可能会有所出入，需要稍作修改。




 




## 根据模板文件编译制作内核




首先我们解压内核文件到/usr/src目录下，然后创建一个软链接linux指向这个目录。软链接的目的是为了方便实现多内核版本共存或者切换，在切换内核版本时只需要修改软链接即可。




![](http://118.25.17.78/wp-content/uploads/2018/07/kernel_compile-1.jpg)




进入目录后我们即可开始配置编译选项，在配置完选项保存退出后，就会在该目录下生成一个 .config 文件，这个文件保存了我们所选择的的所有配置信息。但是如果我们直接开始配置的话，就需要手动配置所有的选项，而 linux 的内核配置选项有上千个，如果需要全都配置的话实在是有些复杂，于是我们在这里使用提前准备好的 .config模板文件，避免初次编译内核时直接被大量的选项搞得晕头转向。




而这个模板文件CentOS系统会直接提供给你，在/boot目录下，名为config-$(uname -r)。这个文件是当前CentOS系统在编译内核时所使用的 .config文件，所以使用这个文件作为模板基本不会出问题。我们将它复制过来然后重命名为 .config 即可开始配置。




在这里我们使用make命令进行编译选项的配置，通过make help我们可以查看make命令的使用帮助。




在configuration targets中，我们可以找到很多的配置选项的方法，其中config表示命令行方式配置，此种方式会依次询问你每一个选项，然后你要依次回答，由于有近千个选项，所以最好不要使用这种方法。menuconfig使用的是cursor风格的配置方式。xconfig和gconfig使用的是图形界面的配置方式。在这里我们选择menuconfig。




![](http://118.25.17.78/wp-content/uploads/2018/07/make_help.jpg)




![](http://118.25.17.78/wp-content/uploads/2018/07/make_menuconfig-2-1.jpg)




然后我们就进入了cursor风格的内核选项配置界面。在这里我们可以选择开启或者关闭某个内核功能，将其编译进内核或者编译成模块。在选择完后我们需要保存退出，接下来就可以进行编译了。看起来很容易，实际上这一步配置过程是核心，没有一定的经验和水平是很难配置好一个合适的内核的。




![](http://118.25.17.78/wp-content/uploads/2018/07/make_menuconfig-1.jpg)




在保存退出后，我们就可以使用make进行编译了，在编译时可以指定-j NUM选项，表示编译时同时可以启动几个Job，我们可以根据自己CPU的核心数决定同时跑多少个Job，建议使用-j选项，因为内核编译的过程实在是有一些慢。




由于编译内核所需的时间很长，如果你是用的是远程连接的方式操作主机，那么在编译的过程中一旦发生网络波动等情况导致连接断开，那么之前的编译将前功尽弃。因为编译任务是一个前台进程，而一旦前台进程所在的session意外断开，那么init进程就会向属于该session的所有前台进程发送SIGHUP信号，进程收到SIGHUP信号后就会退出。（详细解释见：[Linux进程管理之作业控制的SIGHUP小节](http://118.25.17.78/blog/2018/06/19/linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%8B%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/#SIGHUP)）我们当然可以将编译任务运行为一个后台进程，但是这么做我们就看不到编译过程了，而且如果编译失败，我们也不方便解决问题后继续编译。




在这里我们可以使用screen命令。







### screen




**GNU Screen**是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。




GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。




**会话恢复**




只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）。这一点和图形界面下的VNC很相似。




**多窗口**




在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。




**会话共享**




Screen可以让一个或多个用户从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，可以对窗口进行密码保护。







在启动编译任务前，我们可以先运行一下screen命令，这样就能够让screen进程打开一个窗口，这个窗口会打开默认的SHELL供用户输入，于是我们可以启动编译任务，在启动后，我们也可以将这个窗口卸下来，这样我们就能够回到原本的SHELL下，同时卸下来的窗口中的进程仍然保持运行。我们在需要使用到这个窗口时可以将它装回来，这样我们就有能够进入窗口中的SHELL了，而且仍然能够正常地运行和输出信息，就仿佛之前什么事都没发生过一样。在这段时间内，只要screen进程没有退出，那么由screen进程管理的所有session都不会因为用户的连接断开而退出。




![](http://118.25.17.78/wp-content/uploads/2018/07/screen.jpg)




首先我们运行screen，然后我们就会进入到一个新的shell中，在这个新的shell中我们运行make -j 2，表示同时运行两个Job，然后我们键入Ctrl+a，放开后再键入d，就能够将这个窗口卸载。然后命令行中就会打印出[detached]表示该窗口被卸载。




我们可以通过screen -ls查看所有的窗口状态和窗口id（6334）。通过这个id我们可以将窗口恢复。




运行screen -r 6443即可恢复窗口。




 




在编译完成后，运行make modules_install和make install分别安装内核模块和内核。最后重启系统即可测试使用新内核。












